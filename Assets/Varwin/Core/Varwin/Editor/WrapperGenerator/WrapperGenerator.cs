using System;
using System.CodeDom;
using System.Collections;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Reflection;
using Microsoft.CSharp;
using UnityEditor;
using UnityEngine;
using Varwin.Public;

namespace Varwin.Editor
{
    public class WrapperGenerator
    {
        private static string WrapperTemplatePath = @"/Varwin/Core/Templates/ObjectWrapper.txt";
        private static string WrapperAutogenerationMark = @"VARWIN_AUTOGEN_MARK_1.0";

        public static void RemoveWrapperIfNeeded(VarwinObjectDescriptor varwinObjectDescriptor)
        {
            string wrapperPath = GetWrapperPath(varwinObjectDescriptor);
            
            if (File.Exists(wrapperPath))
            {
                string oldWrapperCode = File.ReadAllText(wrapperPath);

                if (oldWrapperCode.Contains(WrapperAutogenerationMark))
                {
                    File.Delete(wrapperPath);
                }
            }
        }
        
        public static void GenerateWrapper(VarwinObjectDescriptor varwinObjectDescriptor)
        {
            string wrapperPath = GetWrapperPath(varwinObjectDescriptor);
            
            //Check if this wrapper is autogenerated
            if (File.Exists(wrapperPath))
            {
                string oldWrapperCode = File.ReadAllText(wrapperPath);

                if (!oldWrapperCode.Contains(WrapperAutogenerationMark))
                {
                    Debug.LogWarning($"Wrapper {wrapperPath} is not autogenerated! It would not be overwrite.");
                    return;
                }
            }

            string assemblyName = varwinObjectDescriptor.Name + "_" + varwinObjectDescriptor.RootGuid.Replace("-", "");
            Assembly assembly = Assembly.Load(assemblyName);

            if (assembly == null)
            {
                string message = $"Can't generate wrapper: Assembly {assemblyName} has not found!";
                EditorUtility.DisplayDialog("Error!", message, "Ok");
                Debug.LogError(message);
                return;
            }
            
            string typeName =  "Varwin.Types." + assemblyName + "." + varwinObjectDescriptor.Name;
            Type mainScriptType = assembly.GetType(typeName);

            if (mainScriptType == null)
            {
                mainScriptType = assembly.GetTypes().FirstOrDefault(x => x.IsSubclassOf(typeof(VarwinObject)));
            }
            
            if (mainScriptType == null)
            {
                string message = $"Can't generate wrapper: {typeName} in assembly {assemblyName} has not found!";
                EditorUtility.DisplayDialog("Error!", message, "Ok");
                Debug.LogError(message);
                return;
            }

            string wrapperText = GenerateWrapperText(mainScriptType, varwinObjectDescriptor.Name, varwinObjectDescriptor.RootGuid.Replace("-", ""));
            
            File.WriteAllText(wrapperPath, wrapperText);
            
        }

        private static string GenerateWrapperText(Type mainScriptType, string objectName, string cleanGuid)
        {
            string wrapperCs = File.ReadAllText(Application.dataPath + WrapperTemplatePath);
            wrapperCs = wrapperCs.Replace("{%Object%}", objectName).Replace("{%Guid%}", cleanGuid);
            
            PropertyInfo[] properties = mainScriptType.GetProperties(BindingFlags.Public | BindingFlags.Instance);
            MethodInfo[] methods = mainScriptType.GetMethods(BindingFlags.Public | BindingFlags.Instance);
            EventInfo[] events = mainScriptType.GetEvents(BindingFlags.Public | BindingFlags.Instance);
            FieldInfo[] fields = mainScriptType.GetFields(BindingFlags.Public | BindingFlags.Instance);

            wrapperCs = wrapperCs.Replace("{%Values%}", GenerateValues(fields));
            wrapperCs = wrapperCs.Replace("{%Properties%}", GenerateProperties(properties));
            wrapperCs = wrapperCs.Replace("{%Checkers%}", GenerateCheckers(methods));
            wrapperCs = wrapperCs.Replace("{%Actions%}", GenerateActions(methods));
            wrapperCs = wrapperCs.Replace("{%Events%}", GenerateEvents(events));
            wrapperCs = wrapperCs.Replace("{%EventsSubscription%}", GenerateEventsSubscriptions(events));
            wrapperCs = wrapperCs.Replace("{%Dynamics%}", GenerateDynamics(methods));
            
            return wrapperCs;
        }

        private static string GetWrapperPath(VarwinObjectDescriptor varwinObjectDescriptor)
        {
            return Path.GetDirectoryName(varwinObjectDescriptor.Prefab) + "\\" + varwinObjectDescriptor.Name + "Wrapper.cs";
        }
        
#region Basic generators

        private static string GenerateValues(FieldInfo[] fields)
        {
            string values = "";

            foreach (FieldInfo field in fields)
            {
                ValueAttribute value = field.GetCustomAttribute<ValueAttribute>();

                if (value != null)
                {
                    values += GenerateSingleValue(field, value);
                }
            }
            
            return values;
        }

        private static string GenerateProperties(PropertyInfo[] properties)
        {
            string gettersAndSetters = "";

            foreach (PropertyInfo property in properties)
            {
                GetterAttribute getter = property.GetCustomAttribute<GetterAttribute>();
                SetterAttribute setter = property.GetCustomAttribute<SetterAttribute>();

                if (getter != null || setter != null)
                {
                    gettersAndSetters += GenerateGetterAndSetter(property, getter, setter);
                }
            }
            
            return gettersAndSetters;
        }
        
        private static string GenerateCheckers(MethodInfo[] methods)
        {
            string checkers = "";

            foreach (MethodInfo method in methods)
            {
                CheckerAttribute checker = method.GetCustomAttribute<CheckerAttribute>();

                if (checker != null)
                {
                    checkers += GenerateChecker(method, checker);
                }
            }
            
            return checkers;
        }
        
        private static string GenerateActions(MethodInfo[] methods)
        {
            string actionsCode = "";

            foreach (MethodInfo method in methods)
            {
                ActionAttribute action = method.GetCustomAttribute<ActionAttribute>();

                if (action != null)
                {
                    actionsCode += GenerateAction(method, action);
                }
            }
            
            return actionsCode;
        }
        
        private static string GenerateEvents(EventInfo[] events)
        {
            string eventsCode = "";

            foreach (EventInfo eventInfo in events)
            {
                EventAttribute eventAttribute = eventInfo.GetCustomAttribute<EventAttribute>();

                if (eventAttribute != null)
                {
                    eventsCode += GenerateEventCode(eventInfo, eventAttribute);
                }
            }
            
            return eventsCode;
        }

        private static string GenerateEventsSubscriptions(EventInfo[] events)
        {
            string subscriptionsCode = "";

            foreach (EventInfo eventInfo in events)
            {
                EventAttribute eventAttribute = eventInfo.GetCustomAttribute<EventAttribute>();

                if (eventAttribute != null)
                {
                    subscriptionsCode += GenerateEventSubscriptionCode(eventInfo);
                }
            }
            
            return subscriptionsCode;
        }
        
        private static string GenerateDynamics(MethodInfo[] methods)
        {
            return "";
        }
        
 #endregion

#region Block generators

 private static string GenerateSingleValue(FieldInfo field, ValueAttribute value)
 {
     string singleValueField = "";

     singleValueField += "[Value(\"" + value.Name + "\")]\n";
     singleValueField += GenerateLocalization(field);
     singleValueField += "public string " + field.Name + ";\n\n"; 

     return singleValueField;
 }
 
 private static string GenerateGetterAndSetter(PropertyInfo property, GetterAttribute getter, SetterAttribute setter)
 {
     string getterSetterField = "";

     if (getter != null)
     {
         getterSetterField += "[Getter(\"" + getter.Name + "\")]\n";
     }

     if (setter != null)
     {
         getterSetterField += "[Setter(\"" + setter.Name + "\")]\n";
         getterSetterField += GenerateSetterValues(property);
     }
    
     getterSetterField += GenerateLocalization(property);
     
     string typeName;
     using (var provider = new CSharpCodeProvider())
     {
         var typeRef = new CodeTypeReference(property.PropertyType);
         typeName = provider.GetTypeOutput(typeRef);
     }

     getterSetterField += "public " + typeName + " " + property.Name + " {\n";

     if (getter != null)
     {
         getterSetterField += "get { return _object." + property.Name + "; }\n";
     }

     if (setter != null)
     {
         getterSetterField += "set { _object." + property.Name + " = value; }\n";
     }

     getterSetterField += "}\n\n";

     return getterSetterField;
 }

 private static string GenerateChecker(MethodInfo method, CheckerAttribute checker)
 {
     string checkerField = "";

     checkerField += "[Checker(\"" + checker.Name + "\")]\n";
     checkerField += GenerateLocalization(method);

     checkerField += "public bool " + method.Name + "() { return _object." + method.Name + "(); }\n\n";
     
     return checkerField;
 }

 private static string GenerateAction(MethodInfo method, ActionAttribute action)
 {
     string actionField = "";

     actionField += "[Action(\"" + action.Name + "\")]\n";
     actionField += GenerateActionValues(method);
     actionField += GenerateLocalization(method);

     actionField += "public void " + method.Name + " (";

     ParameterInfo[] parameters = method.GetParameters().OrderBy(p => p.Position).ToArray();


     string paramsCall = "";
     using (var provider = new CSharpCodeProvider())
     {
         for (int i = 0; i < parameters.Length; i++)
         {
             ParameterInfo parameter = parameters[i];
             
             var typeRef = new CodeTypeReference(parameter.ParameterType);
             string paramTypeName = provider.GetTypeOutput(typeRef);

             actionField += paramTypeName + " " + parameter.Name;
             paramsCall += parameter.Name;

             if (i + 1 < parameters.Length)
             {
                 actionField += ", ";
                 paramsCall += ", ";
             }
         }
     }

     actionField += ") { _object." + method.Name + "(" + paramsCall + "); }\n\n";

     return actionField;
 }

 private static string GenerateEventCode(EventInfo eventInfo, EventAttribute eventAttribute)
 {
     string eventField = "";

     eventField += "[Event(\"" + eventAttribute.Name + "\")]\n";
     eventField += GenerateEventValues(eventInfo);
     eventField += GenerateLocalization(eventInfo);
     
     string typeName;
     using (var provider = new CSharpCodeProvider())
     {
         var typeRef = new CodeTypeReference(eventInfo.EventHandlerType);
         typeName = provider.GetTypeOutput(typeRef);
     }

     eventField += "public event " + typeName + " " + eventInfo.Name + ";\n\n";

     eventField += "public void " + eventInfo.Name + "Invoke(";
     
     ParameterInfo[] parameters = eventInfo.EventHandlerType.GetMethod("Invoke").GetParameters().OrderBy(p => p.Position).ToArray();

     string parametersCalling = "";
     using (var provider = new CSharpCodeProvider())
     {
         for (int i = 0; i < parameters.Length; i++)
         {
             ParameterInfo parameter = parameters[i];
             
             var typeRef = new CodeTypeReference(parameter.ParameterType);
             string paramTypeName = provider.GetTypeOutput(typeRef);

             eventField += paramTypeName + " " + parameter.Name;
             parametersCalling += parameter.Name;

             if (i + 1 < parameters.Length)
             {
                 eventField += ", ";
                 parametersCalling += ", ";
             }
         }
     }
     
     eventField += ") { " + eventInfo.Name + "?.Invoke(" + parametersCalling + "); }\n\n";

     return eventField;
 }

 private static string GenerateEventSubscriptionCode(EventInfo eventInfo)
 {
     return "_object." + eventInfo.Name + " += " + eventInfo.Name + "Invoke;\n";
 }
 
 #endregion
 
#region Values generation

 private static string GenerateSetterValues(PropertyInfo property)
 {
     string values = "";

     ValuesAttribute valuesAttr = property.GetCustomAttribute<ValuesAttribute>();

     if (valuesAttr != null)
     {
         values += "[Values(\"" + valuesAttr.Name + "\")]\n";
     }
     
     return values;
 }
 
 private static string GenerateActionValues(MethodInfo method)
 {
     string values = "";

     ValuesAttribute valuesAttr = method.GetCustomAttribute<ValuesAttribute>();

     if (valuesAttr != null)
     {
         values += "[Values(\"" + valuesAttr.Name + "\")]\n";
     }
     
     return values;
 }
 
 private static string GenerateEventValues(EventInfo eventInfo)
 {
     string values = "";

     ValuesAttribute valuesAttr = eventInfo.GetCustomAttribute<ValuesAttribute>();

     if (valuesAttr != null)
     {
         values += "[Values(\"" + valuesAttr.Name + "\")]\n";
     }
     
     return values;
 }
 
 #endregion
 
#region GENERATE LOCALIZATION
 
 private static string GenerateLocalization(FieldInfo field)
 {
     LocaleAttribute[] locales = field.GetCustomAttributes<LocaleAttribute>().ToArray();
     return GenerateLocalizationCode(locales);
 }

 private static string GenerateLocalization(PropertyInfo property)
 {
     LocaleAttribute[] locales = property.GetCustomAttributes<LocaleAttribute>().ToArray();
     return GenerateLocalizationCode(locales);
 }

 private static string GenerateLocalization(MethodInfo method)
 {
     LocaleAttribute[] locales = method.GetCustomAttributes<LocaleAttribute>().ToArray();
     return GenerateLocalizationCode(locales);
 }
 
 private static string GenerateLocalization(EventInfo eventInfo)
 {
     LocaleAttribute[] locales = eventInfo.GetCustomAttributes<LocaleAttribute>().ToArray();
     return GenerateLocalizationCode(locales);
 }

 private static string GenerateLocalizationCode(LocaleAttribute[] locales)
 {
     string localesCode = "";

     foreach (LocaleAttribute locale in locales)
     {
         localesCode += $"\t[Locale(SystemLanguage.{locale.Language}, ";

         for (int i = 0; i < locale.Strings.Length; i++)
         {
             localesCode += "\"" + locale.Strings[i] + "\"";

             if (i + 1 < locale.Strings.Length)
             {
                 localesCode += ", ";
             }
         }

         localesCode += ")]\n";
     }
     
     return localesCode;
 }

 #endregion
        
    }
}